// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'media.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `CompressProgress`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Exposed via FRB
Future<VideoInfo> getVideoInfo({required String path}) =>
    RustLib.instance.api.crateApiMediaGetVideoInfo(path: path);

Future<String> generateVideoThumbnail({
  required String path,
  required String outputPath,
  required VideoThumbnailParams params,
  bool? emptyImageFallback,
}) => RustLib.instance.api.crateApiMediaGenerateVideoThumbnail(
  path: path,
  outputPath: outputPath,
  params: params,
  emptyImageFallback: emptyImageFallback,
);

Stream<String> generateVideoTimelineThumbnails({
  required String path,
  required String outputPath,
  ImageThumbnailParams? params,
  required int numThumbnails,
  bool? emptyImageFallback,
}) => RustLib.instance.api.crateApiMediaGenerateVideoTimelineThumbnails(
  path: path,
  outputPath: outputPath,
  params: params,
  numThumbnails: numThumbnails,
  emptyImageFallback: emptyImageFallback,
);

Future<String> generateImageThumbnail({
  required String path,
  required String outputPath,
  ImageThumbnailParams? params,
  String? suffix,
}) => RustLib.instance.api.crateApiMediaGenerateImageThumbnail(
  path: path,
  outputPath: outputPath,
  params: params,
  suffix: suffix,
);

Future<CompressionEstimate> estimateCompression({
  required String path,
  required String tempOutputPath,
  required CompressParams params,
}) => RustLib.instance.api.crateApiMediaEstimateCompression(
  path: path,
  tempOutputPath: tempOutputPath,
  params: params,
);

Future<String> compressVideo({
  required String path,
  required String outputPath,
  required CompressParams params,
}) => RustLib.instance.api.crateApiMediaCompressVideo(
  path: path,
  outputPath: outputPath,
  params: params,
);

class CompressParams {
  final int targetBitrateKbps;
  final String? preset;
  final int? crf;
  final int? width;
  final int? height;

  const CompressParams({
    required this.targetBitrateKbps,
    this.preset,
    this.crf,
    this.width,
    this.height,
  });

  @override
  int get hashCode =>
      targetBitrateKbps.hashCode ^
      preset.hashCode ^
      crf.hashCode ^
      width.hashCode ^
      height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CompressParams &&
          runtimeType == other.runtimeType &&
          targetBitrateKbps == other.targetBitrateKbps &&
          preset == other.preset &&
          crf == other.crf &&
          width == other.width &&
          height == other.height;
}

class CompressionEstimate {
  final BigInt estimatedSizeBytes;
  final BigInt estimatedDurationMs;

  const CompressionEstimate({
    required this.estimatedSizeBytes,
    required this.estimatedDurationMs,
  });

  @override
  int get hashCode =>
      estimatedSizeBytes.hashCode ^ estimatedDurationMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CompressionEstimate &&
          runtimeType == other.runtimeType &&
          estimatedSizeBytes == other.estimatedSizeBytes &&
          estimatedDurationMs == other.estimatedDurationMs;
}

class ImageThumbnailParams {
  final ThumbnailSizeType? sizeType;
  final OutputFormat? format;

  const ImageThumbnailParams({this.sizeType, this.format});

  @override
  int get hashCode => sizeType.hashCode ^ format.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ImageThumbnailParams &&
          runtimeType == other.runtimeType &&
          sizeType == other.sizeType &&
          format == other.format;
}

enum OutputFormat {
  webp,
  jpeg,
  png;

  Future<void> extension_() =>
      RustLib.instance.api.crateApiMediaOutputFormatExtension(that: this);
}

class ResolutionPreset {
  final String name;
  final int width;
  final int height;
  final BigInt bitrate;
  final int crf;

  const ResolutionPreset({
    required this.name,
    required this.width,
    required this.height,
    required this.bitrate,
    required this.crf,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      width.hashCode ^
      height.hashCode ^
      bitrate.hashCode ^
      crf.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ResolutionPreset &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          width == other.width &&
          height == other.height &&
          bitrate == other.bitrate &&
          crf == other.crf;
}

@freezed
sealed class ThumbnailSizeType with _$ThumbnailSizeType {
  const ThumbnailSizeType._();

  const factory ThumbnailSizeType.icon() = ThumbnailSizeType_Icon;
  const factory ThumbnailSizeType.small() = ThumbnailSizeType_Small;
  const factory ThumbnailSizeType.medium() = ThumbnailSizeType_Medium;
  const factory ThumbnailSizeType.large() = ThumbnailSizeType_Large;
  const factory ThumbnailSizeType.larger() = ThumbnailSizeType_Larger;
  const factory ThumbnailSizeType.custom((int, int) field0) =
      ThumbnailSizeType_Custom;

  Future<(int, int)> dimensions() =>
      RustLib.instance.api.crateApiMediaThumbnailSizeTypeDimensions(that: this);
}

class VideoInfo {
  final BigInt durationMs;
  final int width;
  final int height;
  final BigInt sizeBytes;
  final BigInt? bitrate;
  final String? codecName;
  final String? formatName;
  final List<ResolutionPreset> suggestions;

  const VideoInfo({
    required this.durationMs,
    required this.width,
    required this.height,
    required this.sizeBytes,
    this.bitrate,
    this.codecName,
    this.formatName,
    required this.suggestions,
  });

  @override
  int get hashCode =>
      durationMs.hashCode ^
      width.hashCode ^
      height.hashCode ^
      sizeBytes.hashCode ^
      bitrate.hashCode ^
      codecName.hashCode ^
      formatName.hashCode ^
      suggestions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VideoInfo &&
          runtimeType == other.runtimeType &&
          durationMs == other.durationMs &&
          width == other.width &&
          height == other.height &&
          sizeBytes == other.sizeBytes &&
          bitrate == other.bitrate &&
          codecName == other.codecName &&
          formatName == other.formatName &&
          suggestions == other.suggestions;
}

class VideoThumbnailParams {
  final BigInt timeMs;
  final ThumbnailSizeType? sizeType;
  final OutputFormat? format;

  const VideoThumbnailParams({
    required this.timeMs,
    this.sizeType,
    this.format,
  });

  @override
  int get hashCode => timeMs.hashCode ^ sizeType.hashCode ^ format.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VideoThumbnailParams &&
          runtimeType == other.runtimeType &&
          timeMs == other.timeMs &&
          sizeType == other.sizeType &&
          format == other.format;
}
